---
title: "session3"
author: "Kevin Wang and Garth Tarr"
date: "05/11/2019"
output:
  html_document:
    css: style.css
---



# Learning outcomes of this session

+ tibbles are better than data.frames
+ More plotting with `ggplot2`
+ `for` loops and `purrr::map` functions
+ Modelling with `broom`



# Loading packages

```{r}
library(tidyverse)
```


# Loading cleaned sample data


This session3 data is almost identical to the `wide_sample_ge_data.csv` file that we just saved. Except that we actually used all the genes in the database. 

```{r}
session3_data = read_csv(file = "data/session3_data.csv") %>% 
  dplyr::select(-time, -dose)

clean_data = session3_data %>% 
  dplyr::mutate_if(is.numeric, .funs = log)

clean_data
```


# t-test

A typical task in bioinformatics is to perform differential gene expression analysis. That is, we want to identify genes that has a different expression patterns between two conditions. While there are many ways that this can be done, we will opt for the simplest approach of using a t-test. 

In `R`, t-test can be performed using the `t.test` function. Below, we will perform a t-test on the Ahrrr gene between the two strains of mice. 

```{r}
t.test(Ahrr ~ strain, data = clean_data)
```

However, the output of the `t.test` function can be a bit hard to read or manipulate into a data.frame. This is where the `tidy()` function from the `broom` package can help.

```{r}
t.test(Ahrr ~ strain, data = clean_data) %>% 
  broom::tidy()
```


Similarly, we can do the same for the Cxcr7 gene. 

```{r}
t.test(Cxcr7 ~ strain, data = clean_data) %>% 
  broom::tidy()
```



# `for` loops

`for` loops are common in any programming language. It simply list out the instructions and the iterations are specified using an index. For example, the following code prints out 1 to 5.

```{r}
for (i in 1:5){
  print(i)
}
```

In the `clean_data`, we have 54 genes in total. If we want to perform t-test on each gene, should we type out 54 lines of code? 

The answer is obviously no. Because such practice is very time inefficient and not generalisable if we receive another dataset in the future. 


We can use the `for` loop to go through each column in `clean_data`, calculate the t-test statistics and print them out. However, this output is often not plotting-friendly because it is to merge this output with the original gene expression values. 

```{r, eval = FALSE}
for(i in 3:56){
  t.test(clean_data %>% pull(i) ~ clean_data$strain) %>%
    broom::tidy() %>% 
    print()
}
```

This is why we want to use a tidyverse framework to achive the same thing. 


# Nesting data

Now, let's think about the task of calculating a t-test for each gene. This may seem like a very difficult task, but we can identify some of its components to achieve simplifications and generalisations. 

First, we should run the `t.test` and the `broom::tidy` function on gene expression values for a selected gene. Then, we do exactly the same operation for another 53 genes. So the grand overall task is actually very repetitive and we are really just applying the following function to 54 datasets (each dataset only contains one selected gene). 


```{r}
tidy_test = function(this_data){
  t.test(gene_expression ~ strain, data = this_data) %>% 
    broom::tidy()
}
```



So now, our very difficult task of performing 54 t-tests is simplified to spliting `clean_data` into 54 datasets, one for each gene. 

While there are many ways this can be done in `R`, we will use a `tidyverse` framework that has the advantage of readable codes and generalisability. 

First, let's pivot our data into a long format. 

```{r}
gene_long = clean_data %>%
  tidyr::pivot_longer(
    cols = -c("strain", "sample"),
    names_to = "gene_symbol",
    values_to = "gene_expression")

gene_long
```


Then we will use the `group_by` function and then apply the `nest` function from the `tidyr` package. 

```{r}
gene_nest = gene_long %>% 
  group_by(gene_symbol) %>% 
  tidyr::nest(.key = "small_data") %>% 
  dplyr::ungroup()

gene_nest

gene_nest$small_data[1:2]
```


So, a lot of things happened here. Let's explain. 

You might remember the `group_by` function when we were trying to use the `summarise` function to calculate summary statistics. This is exactly what we want to achieve with `gene_nest`. 

Each gene had 154 observations (number rows of `clean_data`), but in `gene_nest`, each gene only has "one observation", which corresponds to a row in the `small_data` column. **Each row of the `small_data` column is a `data.frame` of size 154 rows and 3 columns** (indicated by the `[154 x 3]`). In each of the `[154 x 3]` data.frame, you will see three columns (all the columns that we didn't put into `group_by`). 

Remember, our original aim is to split the `gene_long` data into 54 smaller data, and we have achived that here with the `small_data` column. 


Now, we simply need to apply the `tidy_test` function onto the `small_data` column in this `gene_nest` data.frame. 

```{r, eval = FALSE}
for(i in 1:54){
  tidy_test(gene_nest$small_data[[i]])
}
```


# `map` function in `purrr`

We could use the `for` loop to compute the `tidy_test` output for all 54 genes. 

```{r, eval = FALSE}
for (i in 1:54){
  tidy_test(gene_nest$small_data[[i]])
}
```

However, the output of this loop is a `list` object requiring further manipulations to make it suitable for visualisation purposes. Hence, we will learn a new way for plotting. 

The `map` function from the `purrr` package is a tremendously powerful function. In simply terms, it allows us to write a `for` loop is a very simply and readable way. 

```{r, eval = FALSE}
purrr::map(.x = gene_nest$small_data,
           .f = tidy_test)
```


Why is this code better than the `for` loop even though they achieved the same output? The biggest reason is that **we don't have to read and understand individual lines** inside the `for` loop. We simply need to know: 

+ `.x`, the input
+ `.f`, the function

Then the function `.f` will be applied onto every element of the `.x` input. 

Another reason why `map` function is superior to a `for` loop is how easy it can work with the `mutate` function in `dplyr`. The following code can be read as: 

+ In the `gene_nest` data, we want to `mutate` (create) a new column
+ This new column will be called `tidy_result` and it is defined as mapping the `tidy_test` function to every element if the `small_data` column. 

```{r}
gene_test = gene_nest %>% 
  dplyr::mutate(
    tidy_result = purrr::map(
      .x = small_data,
      .f = tidy_test)
  )

gene_test
```


This is a very powerful framework, because it allows us to create new statistics horizonally inside a `data.frame`, keep in track of the matching genes/observations. You may not realise this, but one of the most common mistake in data analysis is mis-matching of rows when combining datasets and statistics. The use of the `mutate` and `map` functions allows all intermediate steps to be stored as a column inside a data.frame, precenting any mis-matchings. 

# Plotting t-test results

The `tidy_result` column in `gene_test` is now a list of tibbles (think of them as data.frames). Each of these tibbles contains t-test statistic and p-value associated with each gene. We will now need to expand this column. The function we will use is `unnest` from the `tidyr` package. As you may already guess, this function undo the `nest` operation. In this case, we want to undo the `tidy_result` column only. 

```{r}
gene_test$tidy_result[1:2]

gene_test_long = gene_test %>% 
  tidyr::unnest(tidy_result)

gene_test_long
```

Armed with all the t-test statistics and p-values, we may want to perform some quick visualisations. 

```{r}
gene_test_long %>% 
  ggplot(aes(x = p.value)) +
  geom_histogram()
```

This histogram shows that we actually have about 1/3 of genes significantly differentially expressed (DE) between the two strains. This is usually a problem with gene expression analysis because if all t-test assumptions are met, the p-values should be uniformly distributed over the [0,1] interval. This inflation is could be attributed to normalisation issues with the data since we have only taken the most naive approach of taking the logarithm. Additionally, we should also note that this is a _targeted_ gene expression data where genes are typically selected due to differential patterns they showed in pilot studies. We will not commenton the biological implication of this histogram further, but proceed with another common analysis, which is to create boxplots of the top differentially expressed genes. 


## Boxplots of top differentially expressed genes

In this section, we will first extract the top 6 DE genes and make a boxplot for each of them between the two strains.

The following code allows us to subset the data.frame to the 6 genes with smallest p-values (i.e. most differentially expressed). However, we shouldn't forget that all the gene expression values are still stored in the `small_data` column. We need to apply the `unnest` operation to extract these values.

```{r}
gene_test_long %>% 
  dplyr::filter(rank(p.value) <= 6) 

boxplot_data = gene_test_long %>% 
  dplyr::filter(rank(p.value) <= 6) %>% 
  tidyr::unnest(small_data)

boxplot_data
```



And now, let's perform the final plotting! 

```{r}
boxplot_data %>% 
  ggplot(aes(x = strain, 
             y = gene_expression)) +
  geom_boxplot() +
  facet_wrap(~ gene_symbol, scales = "free")
```


We can also prettify the plots by creating a `label` column, which combines the gene symbols and p-values. 

```{r}
boxplot_data %>% 
  dplyr::mutate(label = paste0(
    gene_symbol, ", p-value = ", signif(p.value, 2))) %>% 
  ggplot(aes(x = strain, 
             y = gene_expression)) +
  geom_boxplot() +
  facet_wrap(~ label, scales = "free") +
  labs(x = "Strains", 
       y = "Gene expression values")
```



<!-- # Regression analysis (extension) -->

<!-- ```{r} -->


<!-- hw_data = clean_data %>%  -->
<!--   dplyr::filter(strain == "HW") -->

<!-- le_data = clean_data %>%  -->
<!--   dplyr::filter(strain == "LE") -->


<!-- clean_data %>%  -->
<!--   ggplot(aes(x = Ahrr, -->
<!--              y = Cxcr7, -->
<!--              colour = strain)) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "lm") -->


<!-- lm(Cxcr7 ~ Ahrr, data = clean_data) -->
<!-- lm(Cxcr7 ~ Ahrr, data = hw_data) -->
<!-- lm(Cxcr7 ~ Ahrr, data = le_data) -->

<!-- lm_Cxcr7_Ahrr = function(this_data){ -->
<!--   lm(Cxcr7 ~ Ahrr, data = this_data) -->
<!-- } -->

<!-- list_data = list( -->
<!--   clean_data = clean_data,  -->
<!--   hw_data = hw_data, -->
<!--   le_data = le_data) -->

<!-- purrr::map(.x = list_data,  -->
<!--            .f = lm_Cxcr7_Ahrr) -->

<!-- purrr::map(.x = list_data,  -->
<!--            .f = lm_Cxcr7_Ahrr) %>%  -->
<!--   purrr::map(.f = broom::tidy) -->
<!-- ``` -->




<!-- ```{r} -->
<!-- gene_long = clean_data %>% -->
<!--   tidyr::pivot_longer( -->
<!--     cols = -c("strain", "Cxcr7", "sample"), -->
<!--     names_to = "gene_symbol", -->
<!--     values_to = "gene_expression") -->

<!-- gene_long -->

<!-- gene_nest = gene_long %>%  -->
<!--   group_by(strain, gene_symbol) %>%  -->
<!--   tidyr::nest() -->

<!-- gene_nest$data[1:2] -->

<!-- lm_Cxcr7_ge = function(this_data){ -->
<!--   lm(Cxcr7 ~ gene_expression, data = this_data) -->
<!-- } -->

<!-- gene_model = gene_nest %>%  -->
<!--   dplyr::mutate(lm_obj = purrr::map(.x = data,  -->
<!--                                     .f = lm_Cxcr7_ge), -->
<!--                 lm_tidy = purrr::map(.x = lm_obj, -->
<!--                                      .f = broom::tidy)) -->



<!-- gene_model_long = gene_model %>%  -->
<!--   dplyr::select(-data, -lm_obj) %>%  -->
<!--   tidyr::unnest(lm_tidy) %>%  -->
<!--   dplyr::select(strain, gene_symbol, term, estimate) %>%  -->
<!--   dplyr::filter(term == "gene_expression") -->


<!-- gene_model_long -->


<!-- gene_model_wide = gene_model_long %>%  -->
<!--   dplyr::ungroup() %>%  -->
<!--   tidyr::pivot_wider(names_from = "strain", -->
<!--                      values_from = "estimate") -->


<!-- gene_model_wide %>%  -->
<!--   ggplot(aes(x = HW, y = LE)) + -->
<!--   geom_point() + -->
<!--   geom_abline(slope = 1, intercept = 0, colour = "red") -->

<!-- gene_model_wide %>%  -->
<!--   ggplot(aes(x = HW, y = LE, -->
<!--              label = gene_symbols)) + -->
<!--   geom_text() + -->
<!--   geom_abline(slope = 1, intercept = 0, colour = "red") -->
<!-- ``` -->





# Session Info
```{r}
sessionInfo()
```

