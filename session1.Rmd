---
title: 'session1'
author: "Kevin Wang and Garth Tarr"
date: "05/11/2019"
output:
  html_document:
    css: style.css
---

# Learning outcomes of this session

+ Understand basic variable types in `R`, in particular the `data.frame`
+ Loading in an Excel sheet as data. 
+ Cleaning columns names 
+ Selection of `data.frame` columns
+ Renaming `data.frame` columns
+ Creating new `data.frame` columns
+ Looking for missing values in `data.frame`
+ Filtering `data.frame` rows
+ Summaring a `data.frame`
+ Saving `data.frame` for next stage of analysis

# Loading packages

```{r, message=FALSE}
library(tidyverse)
library(janitor)
library(readxl)
library(visdat)
```

# Warm up: variable types

Before we take a dive into the `tidyverse`, let's take a quick minute to revise on some variable types in `R`. The reason that we want to do this is because everything in `R` is stored as a variable/object which ultimately determines its behaviours. 

```{r}
logical = c(TRUE, FALSE)
logical
class(logical)

integer = 1:5
integer
class(integer)

numeric = rnorm(5)
numeric
class(numeric)

character = c("a", "b")
character
class(character)

what_am_i = c(integer, character)
what_am_i
class(what_am_i)

how_about_me = list(integer, character)
how_about_me
class(how_about_me[[1]])
class(how_about_me[[2]])

data(diamonds, package = "ggplot2")
diamonds
class(diamonds)
```




# Reading in data

In this session, we will read in a Excel dataset (`xls` format). We will use the [`readxl` package](https://readxl.tidyverse.org/) to perform this task. 

Of course, `xls` is not the only data type that `R` can deal with. Have a look at this [cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf) to see some data types that the [`readr` package](https://readr.tidyverse.org/) is able to handle. If you want to read in SAS or SPSS files, have a look at the [`haven` package](https://haven.tidyverse.org/).  

## First attempt

The `read_xls` function from the `readxl` package is perfect to read in a `xls` data, let's try that!

```{r}
raw_data = readxl::read_xls(path = "data/sample_data.xls")

head(raw_data)
```

Oh, no! We seemed to read in a very ugly dataset. What happened? 

If we open up the `xls` dataset up in Excel, we see that `R` didn't do anything wrong! It actually faithfully read in everything that you can see in the Excel sheet. 
This `xls` data is poorly formatte with the first three rows being non-sense that is not relevant for data analysis. We should ask the function `read_xls` to skip the first three rows, use the 4th row as the data headings. How can we do that?

## Second attempt

Have a look at this!

```{r}
raw_data = readxl::read_xls("data/sample_data.xls", skip = 3)
head(raw_data)
```


# Cleaning column names

The column names of this dataset isn't quite as nice as we would like. For example, the "time" column has some strange symbols. We can remove these using the `clean_names` function from the `janitor` package. Even though this package is not a part of the `tidyverse`, but it is a very useful package nonetheless. 

```{r}
clean_col_data = raw_data %>% 
  janitor::clean_names()

clean_col_data
```


# Selecting data


## Selecting certain columns

We will now use the `dplyr` package to perform some basic data cleaning. The `dplyr` package is one of the most popular packages inside the `tidyverse`. Its main functions are designed to interact with the `data.frame` object in `R` in a very intuitive way. This is why its name is an excellent pun: it is a **ply**e**r** for  **d**ata (okay, maybe it depends on your sense of humour). 

Let's see `dplyr` in action. If we want to select only the `strain` column of this data, then we can use the `select` function from the `dplyr` package.


```{r}
sub_data = clean_col_data %>% 
  dplyr::select(strain)

sub_data
```


# Selecting columns by character vector

If we want to select multiple columns in the data, we could include more names (unquoted) into the `select` function. 

However, sometimes it is useful to select columns using a character vector, especially considering the "dose" column has a Greek symbol (nano-gram) inside. 


```{r}
clean_col_data %>% 
  dplyr::select(strain, sample)


colnames(clean_col_data) %>% tolower()
select_columns = colnames(clean_col_data)[1:4]
select_columns

sub_data = clean_col_data %>% 
  dplyr::select(one_of(select_columns))

sub_data
```


# Renaming columns

We can also rename the columns. 

```{r}
sub_data %>% 
  dplyr::rename(time = time_hours)

rename_columns = c("strain", "sample", "time", "dose")

sub_data = sub_data %>% 
  dplyr::rename_at(vars(select_columns), ~ rename_columns)

sub_data 
```

# Mutating columns

The `mutate` function in `dplyr` does exactly what you would expect: it changes an entire column. It has the structure that `new column = some changes to the (old column)`. 

```{r}
sub_data %>% 
  dplyr::mutate(time_2 = as.numeric(time))
```

If the new column has the same name as the old column, then this column will be over-written. 

```{r}
mutate_data =  sub_data %>% 
  dplyr::mutate(time = as.numeric(time),
                dose = as.numeric(dose))

mutate_data
```


# Missing values 

When we mutated our data, we saw that there was a warning message about `NA`, which is `R`'s way to represent a missing value. So what happened?

If we have a quick look at the original `xls` file, we see that someone must have copied the data with the heading four times. This is why when we converted `time` into a numeric variable, `R` recognised the column headings in the middle of the data as weird values and assigned those with `NA`. 

We can visualise `NA` in our data using the `vis_miss` function from `visdat`. 


```{r}
mutate_data %>% 
  visdat::vis_miss()
```

# Filtering out problematic rows

We will now filtering out the three rows of column headings, which we have converted into `NA` in the `time` and `dose` columns. 

We will use the `filter` function from the `dplyr` package. The function takes in `logical` vectors of the same length as the `nrow(data)` as the input. 

```{r}
## These are the rows we want to filter out
mutate_data %>% 
  dplyr::filter(is.na(time))


## The reverse of the above is written with a `!`. 
filter_data = mutate_data %>% 
  dplyr::filter(!is.na(time))

filter_data
```


# Making summary statistics 

We will finish today's session with something simple, but powerful. 

If we want to create summary statistics of our data.frame, we need to think about which variable are we summarising over. In this case, we will count the number of samples for each of the strains. 

## Counting number of samples
```{r}
filter_data %>% 
  group_by(strain) %>% 
  count()

filter_data %>% 
  group_by(strain) %>% 
  summarise(n())
```

## Counting with more variables



```{r}
filter_data %>% 
  group_by(strain, dose) %>% 
  count()

filter_data %>% 
  group_by(strain, dose, time) %>% 
  count()
```



# Saving data

```{r}
write_csv(filter_data, path = "data/clean_sample_data.csv")
```


# Session Info 
```{r}
sessionInfo()
```

